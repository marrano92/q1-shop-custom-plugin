{
  "name": "SEO Keyword Research",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "seo-keyword-research",
        "authentication": "headerAuth",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [256, 304],
      "webhookId": "c9324432-1069-482e-94ac-399c5860aa7e",
      "credentials": {
        "httpHeaderAuth": {
          "id": "NZcE8PYjuCxc0c1R",
          "name": "Header Auth account 5"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.dataforseo.com/v3/keywords_data/google_ads/keywords_for_keywords/live",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify([{ keywords: [$json.body.keyword_seed], location_name: 'Italy', language_name: 'Italian', search_partners: false }]) }}",
        "options": {}
      },
      "id": "dataforseo-api",
      "name": "DataForSEO API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [480, 304],
      "credentials": {
        "httpBasicAuth": {
          "id": "REPLACE_WITH_DATAFORSEO_CREDENTIAL_ID",
          "name": "DataForSEO API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse DataForSEO API response into structured keyword data\nconst input = $input.first().json;\nconst seedKeyword = $('Webhook Trigger').first().json.body.keyword_seed;\nconst context = $('Webhook Trigger').first().json.body.context || '';\n\nconst tasks = input.tasks || [];\nconst task = tasks[0] || {};\n\nif (task.status_code !== 20000) {\n  return [{ json: { keywords: [], keywordsForAI: [], seed: seedKeyword, context: context, error: task.status_message || 'DataForSEO error' } }];\n}\n\nconst results = task.result || [];\n\nconst keywords = results.map(r => {\n  const monthlySearches = r.monthly_searches || [];\n  const sorted = monthlySearches\n    .sort((a, b) => (a.year * 100 + a.month) - (b.year * 100 + b.month))\n    .slice(-12);\n  const trend_12m = sorted.map(m => m.search_volume || 0);\n  while (trend_12m.length < 12) trend_12m.unshift(0);\n\n  return {\n    term: r.keyword || '',\n    volume: r.search_volume || 0,\n    competition: (r.competition || 'UNSPECIFIED').toUpperCase(),\n    competition_index: r.competition_index || 0,\n    trend_12m: trend_12m,\n    cpc: r.cpc || 0\n  };\n}).filter(k => k.volume > 0);\n\nkeywords.sort((a, b) => b.volume - a.volume);\n\nconst allKeywords = keywords.slice(0, 50);\n// Send only top 25 to AI to stay within token limits\nconst keywordsForAI = allKeywords.slice(0, 25);\n\nreturn [{ json: { keywords: allKeywords, keywordsForAI: keywordsForAI, seed: seedKeyword, context: context } }];"
      },
      "id": "parse-data",
      "name": "Parse Keyword Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [704, 304]
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list"
        },
        "messages": {
          "values": [
            {
              "content": "Sei un esperto SEO specializzato nel mercato italiano. Analizza le keyword fornite e arricchiscile con informazioni utili per un content strategist.",
              "role": "system"
            },
            {
              "content": "={{ 'Analizza queste keyword per il mercato italiano.\\n\\nKeyword seed: ' + $json.seed + '\\nContesto sito: ' + $json.context + '\\n\\nKeyword con dati (top 25 per volume):\\n' + JSON.stringify($json.keywordsForAI, null, 2) + '\\n\\nPer ogni keyword:\\n1. Classifica l\\'intento di ricerca: \"informazionale\", \"transazionale\" o \"navigazionale\"\\n2. Scrivi un breve commento (max 1 frase) sulla qualitÃ /pertinenza della keyword per un blog e-commerce italiano\\n3. Suggerisci fino a 5 keyword long-tail aggiuntive non presenti nella lista, con intento e commento\\n\\nRispondi SOLO con JSON valido nel formato:\\n{\\n  \"analyzed_keywords\": [{\"term\": \"...\", \"intent\": \"...\", \"ai_comment\": \"...\"}],\\n  \"additional_keywords\": [{\"term\": \"...\", \"volume\": 0, \"competition\": \"UNKNOWN\", \"competition_index\": 0, \"trend_12m\": [], \"cpc\": 0, \"intent\": \"...\", \"ai_comment\": \"...\"}]\\n}' }}"
            }
          ]
        },
        "options": {
          "maxTokens": 4096,
          "temperature": 0.3
        }
      },
      "id": "ai-analyze",
      "name": "AI Keyword Analysis",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [928, 304],
      "credentials": {
        "openAiApi": {
          "id": "REPLACE_WITH_OPENAI_CREDENTIAL_ID",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge keyword data with AI analysis\nconst kwData = $('Parse Keyword Data').first().json;\nconst raw = $input.first().json;\n\n// Try multiple output formats from different n8n OpenAI node versions\nlet aiResponseRaw = '';\nif (typeof raw === 'string') {\n  aiResponseRaw = raw;\n} else if (raw.message?.content) {\n  aiResponseRaw = raw.message.content;\n} else if (raw.text) {\n  aiResponseRaw = raw.text;\n} else if (raw.output) {\n  aiResponseRaw = raw.output;\n} else if (raw.content) {\n  aiResponseRaw = raw.content;\n} else if (Array.isArray(raw) && raw[0]?.message?.content) {\n  aiResponseRaw = raw[0].message.content;\n} else if (raw.choices?.[0]?.message?.content) {\n  aiResponseRaw = raw.choices[0].message.content;\n} else {\n  // Last resort: stringify and try to find JSON inside\n  aiResponseRaw = JSON.stringify(raw);\n}\n\nlet aiData;\ntry {\n  const jsonMatch = aiResponseRaw.match(/```json?\\n?([\\s\\S]*?)\\n?```/) || [null, aiResponseRaw];\n  aiData = JSON.parse(jsonMatch[1]);\n} catch (e) {\n  // Try parsing the raw string directly\n  try {\n    aiData = JSON.parse(aiResponseRaw);\n  } catch (e2) {\n    aiData = { analyzed_keywords: [], additional_keywords: [] };\n  }\n}\n\n// Merge AI analysis into keyword data\nconst enrichedKeywords = kwData.keywords.map(kw => {\n  const aiInfo = (aiData.analyzed_keywords || []).find(a =>\n    a.term.toLowerCase() === kw.term.toLowerCase()\n  );\n  return {\n    ...kw,\n    intent: aiInfo?.intent || 'informazionale',\n    ai_comment: aiInfo?.ai_comment || ''\n  };\n});\n\n// Add AI-suggested keywords\nconst additionalKeywords = (aiData.additional_keywords || []).map(kw => ({\n  term: kw.term,\n  volume: kw.volume || 0,\n  competition: kw.competition || 'UNKNOWN',\n  competition_index: kw.competition_index || 0,\n  trend_12m: kw.trend_12m || [],\n  cpc: kw.cpc || 0,\n  intent: kw.intent || 'informazionale',\n  ai_comment: kw.ai_comment || 'Suggerita dall\\'AI'\n}));\n\nconst allKeywords = [...enrichedKeywords, ...additionalKeywords];\n\nreturn [{\n  json: {\n    success: true,\n    keywords: allKeywords,\n    meta: {\n      seed: kwData.seed,\n      total_results: allKeywords.length,\n      timestamp: new Date().toISOString()\n    }\n  }\n}];"
      },
      "id": "merge-results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1280, 304]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1504, 304]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{ "node": "DataForSEO API", "type": "main", "index": 0 }]]
    },
    "DataForSEO API": {
      "main": [[{ "node": "Parse Keyword Data", "type": "main", "index": 0 }]]
    },
    "Parse Keyword Data": {
      "main": [[{ "node": "AI Keyword Analysis", "type": "main", "index": 0 }]]
    },
    "AI Keyword Analysis": {
      "main": [[{ "node": "Merge Results", "type": "main", "index": 0 }]]
    },
    "Merge Results": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
